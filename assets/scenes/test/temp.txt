#include <type_traits>
class World;

class Renderer;
struct Engine {
    static Engine* m_instance;

    World* m_world;
    Renderer* renderer;

    static Engine* GetEngine()
    {
        return m_instance;
    }

    // May return nullptr if no world exists / is loaded.
    static World* GetWorld()
    {
        return m_instance->m_world;
    }

    // May return nullptr if no such renderer is active.
    template<typename AsRenderer>
    static AsRenderer* GetRenderer()
    {
        return dynamic_cast<AsRenderer>(m_instance->renderer);
    }
    
};

struct EngineComponent 
{
    Engine* m_engine;

};




template<typename EC>
struct EngineComponentSubobject
{
    static_assert(std::is_base_of_v<EngineComponent, EC>, "Error");
    EC* m_component;

    EngineComponentSubobject(EC* component)
    {
        m_component = component;
        m_engine = m_component->m_engine;
    }

    

    Engine* GetEngine() { return m_component->m_engine; }

    template<typename EngineComponent>
    EngineComponent* Get()
    {
        return nullptr;
    }

    template<>
    World* Get<World>()
    {
        if constexpr(std::is_base_of_v<World, EC>) {
            return m_component;
        }
        return m_engine->world;
    }
};



struct World : EngineComponent
{    

};

struct Renderer : EngineComponent
{

};

struct Node
{
    GetWorld()->
    
    
};

struct Asset 
{
    Asset(Asset* a) 
        : Asset(a->GetAssetManager())
        {}

        
}


namespace
{
    void LoadModel(Asset& model)
    {
        new Texture(model->GetAssetManager());
    }
}

struct LightAsset : Node 
{
    LightAsset(Asset* w) : Asset(w)
        {}
}


template<typename NodeType>
NodeType* Create(World* ctx) {
    NodeType* a = new NodeType();
    a->m_world = ctx;
}


struct RendererObj : EngineComponentSubobject<Renderer>
{
    World* m_world;
    

};

int main() 
{
    Node* b;
    b->Get<World>();

    RendererObj* a;
    a->Get<World>();
}
